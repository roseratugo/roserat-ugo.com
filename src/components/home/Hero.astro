---
import { getLangFromUrl } from '../../i18n/utils';

const lang = getLangFromUrl(Astro.url);

const content = {
  fr: {
    greeting: 'Bonjour, je suis',
    role: 'Développeur Web',
    description: 'Je conçois et développe des applications web avec une approche mêlant créativité artistique et rigueur technique.',
    cta1: 'Voir mes projets',
    cta2: 'En savoir plus',
    scroll: 'Défiler',
  },
  en: {
    greeting: "Hi, I'm",
    role: 'Web Developer',
    description: 'I design and develop web applications with an approach blending artistic creativity and technical rigor.',
    cta1: 'View projects',
    cta2: 'Learn more',
    scroll: 'Scroll',
  },
};

const t = content[lang];
---

<section class="hero-section" data-hero>
  <!-- Background grid -->
  <div class="hero-grid"></div>

  <!-- Floating orbs - animated with GSAP only -->
  <div class="hero-orbs" data-hero-orbs>
    <div class="hero-orb hero-orb-1"></div>
    <div class="hero-orb hero-orb-2"></div>
    <div class="hero-orb hero-orb-3"></div>
  </div>

  <!-- Noise texture -->
  <div class="hero-noise"></div>

  <!-- Main content -->
  <div class="container-wide hero-content">
    <div class="hero-grid-layout">
      <!-- Left column -->
      <div class="hero-left">
        <!-- Greeting -->
        <div class="hero-greeting">
          <span class="greeting-line"></span>
          <span class="greeting-text">{t.greeting}</span>
        </div>

        <!-- Name - Interactive with cursor -->
        <h1 class="hero-name" data-magnetic-name>
          <span class="name-row">
            {['U', 'g', 'o'].map((letter, i) => (
              <span class="name-letter" data-letter style={`--i: ${i}`}>{letter}</span>
            ))}
          </span>
          <span class="name-row name-accent">
            {['R', 'o', 's', 'e', 'r', 'a', 't'].map((letter, i) => (
              <span class="name-letter" data-letter style={`--i: ${i + 3}`}>{letter}</span>
            ))}
          </span>
        </h1>

        <!-- Role -->
        <div class="hero-role">
          <span class="role-bracket">[</span>
          <span class="role-text">{t.role}</span>
          <span class="role-bracket">]</span>
        </div>

        <!-- Description -->
        <p class="hero-desc">{t.description}</p>

        <!-- CTAs -->
        <div class="hero-ctas">
          <a href={`/${lang}/${lang === 'fr' ? 'projets' : 'projects'}`} class="btn-primary" data-magnetic>
            <span>{t.cta1}</span>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" width="16" height="16">
              <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
            </svg>
          </a>
          <a href={`/${lang}/${lang === 'fr' ? 'a-propos' : 'about'}`} class="btn-secondary-light" data-magnetic>
            <span>{t.cta2}</span>
          </a>
        </div>
      </div>

      <!-- Right column - Stats -->
      <div class="hero-right">
        <div class="hero-stats">
          {[
            { num: '3+', label: lang === 'fr' ? "Ans d'expérience" : 'Years experience' },
            { num: '24h', label: lang === 'fr' ? 'Du Code - Vainqueur' : 'of Code - Winner' },
            { num: '∞', label: lang === 'fr' ? 'Curiosité' : 'Curiosity' },
          ].map((stat, i) => (
            <div class="stat-card" data-tilt="5" style={`--i: ${i}`}>
              <div class="stat-glow"></div>
              <div class="stat-number">{stat.num}</div>
              <div class="stat-label">{stat.label}</div>
            </div>
          ))}
        </div>
      </div>
    </div>
  </div>

  <!-- Scroll indicator -->
  <div class="hero-scroll">
    <div class="scroll-mouse">
      <div class="scroll-wheel"></div>
    </div>
    <span class="scroll-text">{t.scroll}</span>
  </div>
</section>

<style>
  .hero-section {
    position: relative;
    min-height: 100vh;
    display: flex;
    align-items: center;
    overflow: hidden;
    background-color: var(--color-ink);
  }

  .hero-grid {
    position: absolute;
    inset: 0;
    opacity: 0.03;
    background-image:
      linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
    background-size: 80px 80px;
  }

  .hero-orbs {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .hero-orb {
    position: absolute;
    border-radius: 50%;
    filter: blur(60px);
  }

  .hero-orb-1 {
    top: 20%;
    right: 15%;
    width: 300px;
    height: 300px;
    background: radial-gradient(circle, var(--color-accent) 0%, transparent 70%);
    opacity: 0.15;
  }

  .hero-orb-2 {
    bottom: 20%;
    left: 10%;
    width: 200px;
    height: 200px;
    background: radial-gradient(circle, var(--color-accent) 0%, transparent 70%);
    opacity: 0.08;
  }

  .hero-orb-3 {
    top: 50%;
    left: 40%;
    width: 150px;
    height: 150px;
    background: radial-gradient(circle, var(--color-accent) 0%, transparent 70%);
    opacity: 0.05;
  }

  .hero-noise {
    position: absolute;
    inset: 0;
    opacity: 0.015;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
    pointer-events: none;
  }

  .hero-content {
    position: relative;
    z-index: 10;
    padding-top: 8rem;
    padding-bottom: 5rem;
  }

  .hero-grid-layout {
    display: grid;
    grid-template-columns: 1fr;
    gap: 3rem;
    align-items: center;
  }

  @media (min-width: 1024px) {
    .hero-grid-layout {
      grid-template-columns: 2fr 1fr;
      gap: 4rem;
    }
  }

  /* Greeting */
  .hero-greeting {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1.5rem;
    opacity: 0;
    animation: fadeIn 0.6s ease 0.2s forwards;
  }

  .greeting-line {
    width: 40px;
    height: 2px;
    background: linear-gradient(90deg, var(--color-accent), transparent);
  }

  .greeting-text {
    font-family: var(--font-mono);
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    color: var(--color-accent);
  }

  /* Name */
  .hero-name {
    font-family: var(--font-display);
    font-size: clamp(3.5rem, 12vw, 8rem);
    font-weight: 700;
    line-height: 0.9;
    color: var(--color-paper);
    margin-bottom: 1.5rem;
  }

  .name-row {
    display: block;
  }

  .name-letter {
    display: inline-block;
    opacity: 0;
    animation: letterIn 0.5s ease forwards;
    animation-delay: calc(var(--i) * 0.04s + 0.3s);
    cursor: default;
    will-change: transform;
  }

  @keyframes letterIn {
    from {
      opacity: 0;
      transform: translate3d(0, 100%, 0);
    }
    to {
      opacity: 1;
      transform: translate3d(0, 0, 0);
    }
  }

  .name-accent {
    color: var(--color-accent);
  }

  /* Role */
  .hero-role {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    opacity: 0;
    animation: fadeIn 0.6s ease 0.7s forwards;
  }

  .role-bracket {
    font-family: var(--font-mono);
    font-size: 1.25rem;
    color: var(--color-accent);
    opacity: 0.5;
  }

  .role-text {
    font-family: var(--font-mono);
    font-size: 1rem;
    color: var(--color-paper);
    opacity: 0.6;
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }

  /* Description */
  .hero-desc {
    max-width: 500px;
    font-size: 1.125rem;
    color: var(--color-paper);
    opacity: 0;
    line-height: 1.7;
    margin-bottom: 2.5rem;
    animation: fadeIn 0.6s ease 0.9s forwards;
  }

  @keyframes fadeIn {
    to { opacity: 0.6; }
  }

  /* CTAs */
  .hero-ctas {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    opacity: 0;
    animation: fadeUp 0.6s ease 1.1s forwards;
  }

  @keyframes fadeUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .hero-ctas {
    transform: translateY(20px);
  }

  /* Stats */
  .hero-right {
    display: none;
  }

  @media (min-width: 1024px) {
    .hero-right {
      display: block;
    }
  }

  .hero-stats {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
  }

  .stat-card {
    position: relative;
    padding: 1.25rem;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(255, 255, 255, 0.02);
    overflow: hidden;
    opacity: 0;
    transform: translateX(30px);
    animation: slideIn 0.5s ease forwards;
    animation-delay: calc(var(--i) * 0.1s + 0.5s);
  }

  @keyframes slideIn {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  .stat-card:hover {
    border-color: color-mix(in srgb, var(--color-accent) 30%, transparent);
  }

  .stat-glow {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--color-accent), transparent);
    transform: scaleX(0);
    transition: transform 0.3s ease;
  }

  .stat-card:hover .stat-glow {
    transform: scaleX(1);
  }

  .stat-number {
    font-family: var(--font-display);
    font-size: 2rem;
    font-weight: 700;
    color: var(--color-accent);
    margin-bottom: 0.25rem;
  }

  .stat-label {
    font-family: var(--font-mono);
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--color-paper);
    opacity: 0.5;
  }

  /* Scroll indicator */
  .hero-scroll {
    position: absolute;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.75rem;
    opacity: 0;
    animation: fadeIn 0.6s ease 1.5s forwards;
  }

  .scroll-mouse {
    width: 22px;
    height: 36px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 11px;
    position: relative;
  }

  .scroll-wheel {
    position: absolute;
    top: 6px;
    left: 50%;
    transform: translateX(-50%);
    width: 3px;
    height: 6px;
    background-color: var(--color-accent);
    border-radius: 2px;
    animation: scrollAnim 1.5s ease-in-out infinite;
  }

  @keyframes scrollAnim {
    0%, 100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    50% { opacity: 0.3; transform: translateX(-50%) translateY(10px); }
  }

  .scroll-text {
    font-family: var(--font-mono);
    font-size: 0.625rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: var(--color-paper);
    opacity: 0.3;
  }
</style>

<script>
  import { gsap } from 'gsap';

  let nameEffectInitialized = false;
  let orbsEffectInitialized = false;

  // Interactive name effect - letters repel from cursor
  const initNameEffect = () => {
    if (nameEffectInitialized) return;

    const container = document.querySelector('[data-magnetic-name]') as HTMLElement;
    if (!container || window.innerWidth < 768) return;

    const letters = container.querySelectorAll('[data-letter]') as NodeListOf<HTMLElement>;
    if (letters.length === 0) return;

    const maxDist = 150;
    const maxMove = 25;

    // Wait for CSS animations to complete before enabling GSAP
    const lastLetter = letters[letters.length - 1];
    const animDuration = 0.5 + (letters.length - 1) * 0.04 + 0.3; // Match CSS timing

    setTimeout(() => {
      // Clear CSS animation and set initial state with GSAP
      letters.forEach((letter) => {
        letter.style.animation = 'none';
        letter.style.opacity = '1';
        gsap.set(letter, { x: 0, y: 0, scale: 1, clearProps: 'transform' });
      });

      const onMouseMove = (e: MouseEvent) => {
        const rect = container.getBoundingClientRect();

        // Check if cursor is near the name area
        const isNear = (
          e.clientX >= rect.left - 150 &&
          e.clientX <= rect.right + 150 &&
          e.clientY >= rect.top - 100 &&
          e.clientY <= rect.bottom + 100
        );

        if (!isNear) {
          // Reset all letters smoothly
          letters.forEach((letter) => {
            gsap.to(letter, {
              x: 0,
              y: 0,
              scale: 1,
              duration: 0.5,
              ease: 'elastic.out(1, 0.5)'
            });
          });
          return;
        }

        letters.forEach((letter) => {
          const lRect = letter.getBoundingClientRect();
          const letterCenterX = lRect.left + lRect.width / 2;
          const letterCenterY = lRect.top + lRect.height / 2;

          const deltaX = e.clientX - letterCenterX;
          const deltaY = e.clientY - letterCenterY;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          if (distance < maxDist && distance > 0) {
            // Calculate repulsion force (letters push away from cursor)
            const force = (1 - distance / maxDist);
            const moveX = -(deltaX / distance) * force * maxMove;
            const moveY = -(deltaY / distance) * force * maxMove;
            const scale = 1 + force * 0.2;

            gsap.to(letter, {
              x: moveX,
              y: moveY,
              scale: scale,
              duration: 0.3,
              ease: 'power3.out',
            });
          } else {
            gsap.to(letter, {
              x: 0,
              y: 0,
              scale: 1,
              duration: 0.4,
              ease: 'power2.out',
            });
          }
        });
      };

      document.addEventListener('mousemove', onMouseMove);
      nameEffectInitialized = true;
    }, animDuration * 1000 + 100);
  };

  // Orbs follow mouse slightly
  const initOrbsEffect = () => {
    if (orbsEffectInitialized) return;

    const orbsContainer = document.querySelector('[data-hero-orbs]');
    if (!orbsContainer || window.innerWidth < 768) return;

    const orbs = orbsContainer.querySelectorAll('.hero-orb');
    if (orbs.length === 0) return;

    const depths = [15, -10, 20];

    document.addEventListener('mousemove', (e) => {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const ratioX = (e.clientX - centerX) / centerX;
      const ratioY = (e.clientY - centerY) / centerY;

      orbs.forEach((orb, i) => {
        gsap.to(orb, {
          x: ratioX * depths[i],
          y: ratioY * depths[i],
          duration: 1.2,
          ease: 'power2.out',
        });
      });
    });

    orbsEffectInitialized = true;
  };

  // Init function
  const init = () => {
    nameEffectInitialized = false;
    orbsEffectInitialized = false;
    initNameEffect();
    initOrbsEffect();
  };

  // Run on initial load and page transitions
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  document.addEventListener('astro:page-load', init);
</script>
